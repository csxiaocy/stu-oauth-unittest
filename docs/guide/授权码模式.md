# 授权码模式

我们使用了Oauth2.0的**授权码模式**（authorization code），它是功能最完整、流程最严密的授权模式。



## 授权流程

<img :src="$withBase('/授权流程.jpg')" alt="授权流程">


### 核心流程

+ A. 访问业务服务器接口

  该接口由第三方应用传入，在服务器中生成[state](#state作用)并写入session，组装好授权URL（详见[认证参数](#认证参数)），并重定向到授权URL

+ B. 访问授权页面

  访问授权页面前需要先登录，未登录会重定向到登录页面，如果之前登陆过但没有进行授权，且认证服务器的登录态仍有效，则直接能访问授权页面

+ C. 重定向到指定url，并带上授权码code

  重定向的URL是由第三方应用在调起浏览器过程中传入的，认证服务器会在URL的query中在加入code参数和state参数，重定向请求到第三方应用的业务后台，然后从query中取出授权码code和state，比对session的state与query中的state是否一致

  +  如果不一致，证明该请求不是来自需要授权的客户端，授权失败，可能遭到CSRF攻击

+ D. code换取用去用户凭证token

  业务后台拿到授权码后，需要请求认证服务器换取登录凭证token，token可用于调用开放平台所提供的服务

+ E. 授权成功，返回业务后台登录态

  授权成功后，业务后台需要根据自身需求，管理用户的登录态，并给客户端返回自身后台的登录态

+ F. 获取业务后台登录态，退出浏览器

  第三方应用客户端获取到登录态，并退出浏览器



## 认证参数

该部分参数是业务后台组装，以下为GET请求重query所带的参数：

- response_type：表示授权类型，必选项，此处的值固定为"code"
- client_id：表示客户端的ID，必选项
- redirect_uri：表示重定向URI，填业务后台的相关接口URL，可选项
- scope：表示申请的权限范围，可选项
- state：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值，用于防止CSRF。



## 安全性

+ 用户无需在第三方APP输入账号密码，进行登录的流程在开放平台所提供的登录页面完成
+ 附带code的重定向URL，必须在开放平台登记，不能为任意URL，确保code被送到第三方应用的后台服务器
+ 校验session的state与query中的state必须一致，否则拒绝授权，详见[state作用](#state作用)

更多Oauth安全性可以到网上查找资料

[关于 OAuth2.0 安全性你应该要知道的一些事](https://www.chrisyue.com/security-issue-about-oauth-2-0-you-should-know.html)，这篇文章说得比较全，但得花点时间看



### state作用

state参数，是由业务后台动态生成的唯一的随机值，这样确保了，不同的客户端，都拥有着不同的state。将请求加密放入session中，然后跟认证后台重定向后的state进行比对，一致才能确保授权请求来源于同一个客户端。

如果没有state参数，举个可能的攻击例子：

1. 用户A在点击授权后，认证服务器将请求重定向到业务后台指定URL，并带上授权码
2. 黑客B通过技术手段截取了用户A的重定向请求
3. 黑客B在自己客户端发起重定向URL的请求
4. 用户A的授权被黑客B窃取。

业务后台服务器没有办法知道重定向过来的请求，是否为用户A发出的

如果加入了state参数，在业务后台组装授权URL时，会给用户浏览器设置带有state的session，用户每次向业务后台发送请求，都会带上该session。在用户A在请求业务后台时，业务后台能从cookie中取出session，而黑客B的客户端发起的请求，是没有该session的，因此会导致授权失败